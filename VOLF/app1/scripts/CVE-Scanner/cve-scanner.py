import requests
import datetime
import re
import os
import sys
import django

# Konfiguracja ustawien Django
sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/../../../')
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'VOLF.settings')
django.setup()

from app1.models import VulnerabilityFound

# Date formats compatible with Unix
today = datetime.date.today()
yesterday = today - datetime.timedelta(days=1)

date_formats = {
    'date1': yesterday.strftime("%b %d, %Y"),   # Date format: "Jan 01, 2024"
    'tdate1': today.strftime("%b %d, %Y"),      # Date format: "Jan 01, 2024"
    'date2': yesterday.strftime("%d %b %Y"),    # Date format: "01 Jan 2024"
    'tdate2': today.strftime("%d %b %Y"),       # Date format: "01 Jan 2024"
    'date3': yesterday.strftime("%b. %-d, %Y"), # Date format: "Jan. 1, 2024"
    'tdate3': today.strftime("%b. %-d, %Y"),    # Date format: "Jan. 1, 2024"
    'date4': yesterday.strftime("%d %B %Y"),    # Date format: "01 January 2024"
    'tdate4': today.strftime("%d %B %Y"),       # Date format: "01 January 2024"
    'date5': yesterday.strftime("%Y-%m-%d"),    # Date format: "2024-01-30"
    'tdate5': today.strftime("%Y-%m-%d"),       # Date format: "2024-01-30"
}

def create_vuln_in_database(product, link, CVSS, CVE=None):
    date = date_formats["tdate5"]

    # Utworzenie i zapisanie obiektu
    vulnerability = VulnerabilityFound(
        date=date,
        product=product,
        link=link,
        CVSS=CVSS,
        CVE=CVE
    )
    vulnerability.save()

# Optional loading of proxy file
def load_proxy_config(file_path):
    try:
        with open(file_path, 'r') as f:
            lines = f.read().splitlines()
            if len(lines) == 0:
                print("~ proxy_config.txt file is empty. Connection will be made without a proxy.")
                return None
            if len(lines) != 4:
                raise ValueError("Proxy configuration file should contain exactly 4 lines.")
            user, password, host, port = lines
            proxy_url = f"http://{user}:{password}@{host}:{port}"
            return {
                'http': proxy_url,
                'https': proxy_url,
            }
    except FileNotFoundError:
        print("~ proxy_config.txt file does not exist. Connection will be made without a proxy.")
        return None
    except Exception as e:
        print(f"~ Error while loading proxy_config.txt file: {e}")
        return None

proxy = load_proxy_config('/VOLF/app1/scripts/CVE-Scanner/proxy_config.txt')

# Imitating a browser
headers = {
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
}

# Functions related to saving search history in the last_tags.txt file
tag_file_path = '/VOLF/app1/scripts/CVE-Scanner/last_tags.txt'
counter = -1

def increment_counter():
    global counter
    counter += 1
    return counter

def check_last_tags(tag):
    try:
        with open(tag_file_path, 'r+') as f:
            lines = f.read().splitlines()
            if not lines:
                return None
            
            if counter in range(60):
                if tag != lines[counter]:
                    lines[counter] = tag
                    f.seek(0)
                    f.write("\n".join(lines))
                    f.truncate()
                    return True
                else:
                    return False
            else:
                return None
                
    except FileNotFoundError:
        return None
    except Exception:
        return None

# Request function
def make_request(url):
    try:
        if proxy:
            response = requests.get(url, headers=headers, proxies=proxy)
        else:
            response = requests.get(url, headers=headers)
        response.raise_for_status()
        return response
    except requests.exceptions.RequestException as e:
        print(f"~ Failed to access the website: [ {url} ]. Error: '{e}'")
        return None

# Functions searching for vulnerabilities
def find_forti_vulnerabilities(url_forti, software_name):
    increment_counter()
    response = make_request(url_forti)
    if not response:
        return
    
    html_content = response.text

    date_pattern = re.compile(rf'<small><b>Published:</b> <br\s*/?>{re.escape(date_formats["tdate1"])}</small>|<small><b>Published:</b> <br\s*/?>{re.escape(date_formats["date1"])}</small>')
    date_matches = date_pattern.findall(html_content)
 
    if date_matches:
        cve_pattern = re.compile(r'<b class="cve">(CVE-\d{4}-\d{4,7})</b>\s*</div>\s*<div class="col-md-3">', re.DOTALL)
        cve_matches = cve_pattern.findall(html_content)
            
        if cve_matches:
            cve_results = cve_matches[:len(date_matches)]
            cve_results_str = ', '.join(cve_results)
            
            if check_last_tags(cve_results_str):
                create_vuln_in_database(software_name, url_forti, True, cve_results_str)
                print(f"> Found new vulnerabilities: {software_name} - Link to the page: [ {url_forti} ] - List of found vulnerabilities: {cve_results_str}")
            else:
                print(f"~ No vulnerabilities found for: {software_name}")
        else:
            print(f"~ No vulnerabilities found for: {software_name}")
    else:
        print(f"~ No vulnerabilities found for: {software_name}")

def find_microsoft_vulnerabilities(url, product_name):
    increment_counter()
    response = make_request(url)
    if not response:
        return

    xml_content = response.text
    
    pattern = re.compile(rf'isPermaLink=(.*?) {re.escape(date_formats["date2"])}|{re.escape(date_formats["tdate2"])}', re.DOTALL)

    def find_cves(pattern, text):
        matched_CVEs = []
        for match in re.finditer(pattern, text):
            start = text.rfind('isPermaLink=', 0, match.start())
            if start == -1:
                start = 0
            context = text[start:match.end()]
            if product_name in context:
                cve_match = re.search(r'CVE-\d{4}-\d+', context)
                if cve_match:
                    matched_CVEs.append(cve_match.group())
                
        return matched_CVEs
    
    matched_CVEs = find_cves(pattern, xml_content)

    if matched_CVEs:      
        matched_CVEs_str = ', '.join(matched_CVEs)

        if check_last_tags(matched_CVEs_str):
            create_vuln_in_database(f'Microsoft {product_name}', 'https://msrc.microsoft.com/update-guide/vulnerability', False, matched_CVEs)
            print(f"> Found new vulnerabilities: Microsoft {product_name} - Link to the page: [ https://msrc.microsoft.com/update-guide/vulnerability ] - List of found vulnerabilities: {matched_CVEs_str}")
        else:
            print(f"~ No vulnerabilities found for: Microsoft {product_name}")

    else:
        print(f"~ No vulnerabilities found for: Microsoft {product_name}")

def find_postgresql_vulnerabilities(url):
    increment_counter()
    response = make_request(url)
    if not response:
        return

    html_content = response.text
    cve_pattern = re.compile(r'CVE-\d{4}-\d{4,7}')
    cve_numbers = list(dict.fromkeys(cve_pattern.findall(html_content)))
    
    if not cve_numbers:
        return
    
    result_cve_numbers = []
    count = 0
    
    for cve in cve_numbers:
        cve_url = f"{url}{cve}/"
        cve_response = make_request(cve_url)
        if not cve_response:
            continue
            
        cve_html = cve_response.text
        
        if date_formats["date3"] in cve_html or date_formats["tdate3"] in cve_html:
            pattern = r"<strong>(\d+\.\d+)</strong>"
            match = re.search(pattern, cve_html)
            if match:
                number = float(match.group(1))
                if number >= 7:
                    result_cve_numbers.append(cve)
                count += 1
        else:
            continue
    
    if result_cve_numbers:
        result_cve_str = ', '.join(result_cve_numbers)
        if check_last_tags(date_formats["tdate3"]):
            create_vuln_in_database('PostgreSQL', url, False, result_cve_numbers)
            print(f"> Found new vulnerabilities: PostgreSQL - Link to the page: [ {url} ] - List of found vulnerabilities: {result_cve_str}")
        else:
            print(f"~ No vulnerabilities found for: PostgreSQL")
    else:
        print(f"~ No vulnerabilities found for: PostgreSQL")

def find_oracle_vulnerabilities(url):
    increment_counter()
    response = make_request(url)
    if not response:
        return

    html_content = response.text
    found = None
    
    if date_formats["tdate4"] in html_content:
        found = date_formats["tdate4"]
    elif date_formats["date4"] in html_content:
        found = date_formats["date4"]
    
    if found:
        if check_last_tags(found):
            create_vuln_in_database('Oracle', url, False, 'Biuletyn Oracle')
            print(f"> Found new security bulletin: Oracle - Link to the page: [ {url} ]")
        else:
            print("~ No bulletins found for: Oracle")
    else:
        print("~ No bulletins found for: Oracle")
        
def find_atlassian_vulnerabilities(url):
    increment_counter()
    response = make_request(url)
    if not response:
        return

    html_content = response.text
    pattern = re.compile(r'(January |February |March |April |May |June |July |August |September |October |November |December )(.*?)Security Bulletin')
    
    match = pattern.search(html_content)
    title = match.group(0) if match else 'New security bulletin'

    if check_last_tags(title):
        create_vuln_in_database('Atlassian', url, False, f'{title}')
        print(f"> Found new security bulletin: Atlassian - Link to the page: [ {url} ] - Found: {title}")
    else:
        print("~ No bulletins found for: Atlassian")

# Find vulnerabilities for all products

find_forti_vulnerabilities("https://www.fortiguard.com/psirt?filter=1&product=FortiOS-6K7K%2CFortiOS&version=&severity=5&severity=4", "FortiOS")

find_microsoft_vulnerabilities("https://api.msrc.microsoft.com/update-guide/rss", "Windows Server")

find_postgresql_vulnerabilities("https://www.postgresql.org/support/security/")

find_oracle_vulnerabilities("https://www.oracle.com/pl/security-alerts/")

find_atlassian_vulnerabilities("https://www.atlassian.com/trust/security/advisories")